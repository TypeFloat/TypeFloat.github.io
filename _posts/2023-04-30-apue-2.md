---
title: APUE —— VOL.2 文件IO
tags: "APUE"
key: apue-2
sidebar:
  nav: apue
---

本系列是APUE学习的记录笔记，参考了书籍《UNIX环境高级编程》和[视频课程](https://www.bilibili.com/video/BV18p4y167Md/)，本笔记的全部代码可以在[github项目](https://github.com/TypeFloat/Learning-APUE)中进行查看。本章主要讨论UNIX系统文件I/O函数。这些不带缓冲的I/O函数不是ISO C的组成部分，而是POSIX.1和Single UNIX Specification的组成部分。<!--more-->

# 文件描述符

文件描述符通常是一个小的非负整数，内核用以标识一个特定进程正在访问的文件。当内核打开一个现有文件或创建一个新文件时，它都返回一个文件描述符。

按照惯例，UNIX系统shell把**文件描述符0**与进程的**标准输入**关联，**文件描述符1**与进程的**标准输出**关联，**文件描述符2**与进程的**标准错误**关联，在符合`POSIX.1`的UNIX系统中，这虽然已经被标准化，但为了提高程序的可读性，尽量使用符号常量`STDIN_FILENO`、`STDOUT_FILENO`、`STDERR_FILENO`表示。

文件描述符的变化范围是`0~OPEN_MAX-1`，也就是一个进程最多同时打开`OPEN_MAX`个文件。

# 函数open和openat

## 函数open和openat

调用`open`或`openat`函数可以打开或创建一个文件，其函数原型如下所示：

```c
// 若打开成功，返回文件描述符；否则，返回-1
int open(const char *path, int oflag, ...);
int openat(int fd, const char *path, int oflag, ...);
```

参数`oflag`代表打开模式，打开模式实际上是一些预定义的常量，这些常量在`<fcntl.h>中定义`，可用**或运算**选择多个模式，具体可以在UNIX程序手册第二章中查看。

`open`和`openat`函数返回的文件描述符一定是最小的未使用描述符，因此可以用这一点实现标准输入、标准输出、标准错误的重定向。

设计`openat`函数的主要目的是：1）使程序可以使用相对路径名打开任意文件夹的文件，而不是当前工作目录；2）避免产生**TOCTTOU错误**。

**TOCTTOU错误**是指：有两个基于文件的函数调用，其中第二个调用依赖于第一个函数调用结果，因为调用不是原子操作，在两个调用之间一旦文件被修改，那么程序就会出现错误。

## 文件名截断

文件系统对文件名的最大长度有一定限制，由常量`NAME_MAX`定义，若要创建的文件名大于该值，将会出现错误。在POSIX UNIX系统中，错误的处理方法由常量`_POSIX_NO_TRUNC`定义，截断或是通过修改`errno`进行报错，不同的文件系统处理方式不同。

# 函数creat

`creat`函数用于创建一个新文件，其函数原型如下：

```c
// 若创建成功，返回文件描述符；否则，返回-1
int creat(const char *path, mode_t mode);
```

该函数等效于：

```c
open(path, O_WRONLY|O_CREAT|O_TRUNC, mode);
```

从上可以看出，`creat`函数只能以只写的方式打开创建的文件。

# 函数close

`close`函数用于关闭一个打开的文件，其函数原型如下所示：

```c
// 若关闭成功，返回0；否则，返回-1
int close(int fildes);
```

当关闭一个文件时，会自动释放该进程加在此文件上的所有记录锁。当一个进程终止时，内核会自动关闭它打开的所有文件，所以很多程序并不显示地关闭文件。

# 函数lseek

每个打开的文件都有一个值称为**当前文件偏移量**，通常是非负整数，用于度量从文件开始到当前“光标”位置的字节数。通常情况下，读写操作都从当前文件偏移量处开始，并使偏移量增加所读写的字节数。除非追加写的情况，偏移量的初始值都为0。可以调用`lseek`函数显式地调整偏移量，其函数原型如下所示：

```c
// 若成功，返回新的文件偏移量；否则返回-1
off_t lseek(int fd, off_t offset, int whence);
```

注意：如果文件描述符指向的是一个管道、FIFO或网络套接字，则会返回-1，并将`errno`设置为`ESPIPE`。

偏移量通常是非负值，某些设备可能允许负的偏移量，但对于普通文件，其偏移量必须是非负值。因为偏移量可能是负值，所以在检查函数返回值时，一定要确保不等于-1。

文件偏移量可以大于当前文件的大小，在这种情况下，文件的下一次写将加长该文件并形成空洞。文件中的空洞用空字符进行填充，不占用磁盘空间，因为对于原文件尾端到新开始写的位置之间的部分不分配磁盘块。

[示例2-1](https://github.com/TypeFloat/Learning-APUE/blob/main/src/2-1.c)创建了一个具有空洞的文件。

# 函数read

`read`函数用于从打开的文件中读取数据，其函数原型如下所示：

```c
// 若成功，返回读到的字节数；若已经读到文件尾，返回0；否则返回-1
ssize_t read(int fd, void *buf, size_t nbytes);
```

参数`nbytes`表示要读的字节数，但有很多种情况会造成实际读到的字节数少于要读的字节数：

- 在读到要求字节数之前到达文件尾端；
- 当从终端设备读时，通常一次最多读一行；
- 当从网络读时，网络中的缓冲机制可能造成返回值小于所要求读的字节数；
- 当从管道或FIFO读时，如果管道内包含的字节少于要读的，则只会读取管道中现有的所有字节；
- 当从面向记录的设备读时，如磁带，一次最多返回一个记录；
- 当读取操作被信号中断，并且已经读取了部分数据时。

# 函数write

`write`函数用于向打开的文件中写入数据，其函数原型如下所示：

```c
// 若成功，返回已写的字节数；否则返回-1
ssize_t write(int fd, const void *buf, size_t nbytes);
```

`write`函数出错的常见原因是磁盘已满或超过了一个给定进程的文件长度限制。

# I/O的效率

在介绍`read`和`write`函数时，没有很仔细的介绍参数`nbytes`，他表示想要写或读的字节数，实际上这个参数对性能的影响非常大。

[示例2-2](https://github.com/TypeFloat/Learning-APUE/blob/main/src/2-2.c)展示了使用不同缓冲区大小对读写性能的影响。通过运行该示例可以看到两个现象。

第一是，读写速度收到缓冲区大小的影响，但是该影响不是随缓冲区变大而线性减小的，而是缓冲区大小增加到一个值后不再发生明显变化，这个值一般对应着文件系统一个磁盘块的大小。

第二是，当缓冲区还比较小时，读写性能就与很大的缓冲区差距较小了，这是因为大多数文件系统为改善性能都会采用**预读**技术，当检测到正进行顺序读取时，系统会读入比要求的更多数据，所以即使缓冲区较小时，其读写性能也会很好。

# 文件共享

UNIX系统支持在不同进程间共享打开文件，内核使用3种数据结构表示打开文件，如图3-1所示，他们之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响：

1. 每个进程在进程表中有一个记录项，记录项中包含一张打开文件描述符表，可将其视为一个向量，每个描述符占用一项。与文件描述符相关联的有：
   1. 文件描述符标志
   2. 指向一个文件表项的指针
2. 内核为所有打开文件维持一张文件表，每个文件表项包含：
   1. 文件状态标志
   2. 当前文件偏移量
   3. 指向该文件v节点表项的指针
3. 每个打开的文件或设备都有一个v节点结构，该节点包含了文件类型和对此文件进行各种操作函数的指针，对于大多数文件，v节点还包含了该文件的i节点。

![](/assets/posts/apue-2-1.png)

图3-1 打开文件的内核数据结构

如果两个独立进程各自打开了同一个文件，则有图3-2所示的关系。

![](/assets/posts/apue-2-2.png)

图3-2 两个独立进程各自打开同一个文件

打开某个文件的进程都会获得各自的一个文件表项，但对于一个给定的文件只有一个v节点表项，这是因为不同进程对该文件的操作权限和文件偏移量并不相同。

存在多个文件描述符项指向同一文件表项的情况，例如使用`dup`函数或`fork`函数后。注意，文件描述符标志和文件状态标志在作用范围方面的区别，前者指用于一个进程的一个描述符，而后者应用于指向该给定文件表项的任何进程中的所有描述符。

利用文件共享可以使多个进程同时操控一个文件，这在只进行读操作的时候没有任何问题，但如果涉及写操作，不同的读写顺序可能会产生不同的结果。解决这样问题的方法是使用原子操作，任何要求多于一个函数调用的操作都不是原子操作，因为两个函数调用之间，内核可能会临时挂起进程。

# 原子操作

**原子操作**指的是由多步组成的一个操作，如果该操作原子地执行，则要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集。

## 追加到一个文件

如果多个独立的进程使用`O_APPEND`标志打开了一个文件，每次对这种具有追加写标志的文件执行写操作时，文件表项中的当前文件偏移量会首先被移动到i节点表项的文件长度处，这种设定使得每次写入的数据都会追加到文件当前的尾端。但如果不使用`O_APPEND`打开文件，在文件末尾追加内容时，需要依次调用`lseek`和`write`两个函数，此时两个进程同时写文件就可能产生冲突，因为内核在两个函数调用期间可能会切换，解决的方法便是让两个函数操作变为一个内核不可中断的操作，即原子操作。使用`O_APPEND`打开文件时的追加写就是一个原子操作，以这种方式打开文件，写文件时不需要调用`lseek`函数。

## 函数pread和pwrite

函数`pread`和`pwrite`是两个原子操作，他们等价于先调用`lseek`再调用读写函数，但不同的是，这两个函数不会改变当前文件的偏移量。其函数原型如下所示：

```c
// 若成功，返回读到的字节数；若已经读到文件尾，返回0；否则返回-1
ssize_t pread(int d, void *buf, size_t nbyte, off_t offset);

// 若成功，返回已写的字节数；否则返回-1
ssize_t pwrite(int fildes, const void *buf, size_t nbyte, off_t offset);
```

## 创建一个文件

调用`open`函数时，如果指定打开模式为`O_CREAT|O_EXCL`，那么检查文件是否存在和创建文件这两个步骤会被处理为一个原子操作，也是为了避免两个操作过程中内核切换而产生意外错误。

# 函数dup和dup2

函数`dup`和`dup2`用于复制一个现有的文件描述符，其函数原型如下所示：

```c
// 若成功，返回新的文件描述符；否则返回-1
int dup(int fd);
int dup2(int fd, int fd2);
```

`dup`会返回当前可用的最小文件描述符。`dup2`会返回指定的文件描述符`fd2`，如果`fd2`已经打开，则会先将其关闭，如果`fd=fd2`，则会直接返回`fd2`。两个函数返回的文件描述符与参数`fd`共享同一个文件表项，所以共享同一个文件状态标志以及同一当前文件偏移量。

# 函数sync、fsync和fdatasync

UNIX系统在内核中设有缓冲区高速缓存或页高速缓存，大多数磁盘I/O通过缓冲区进行。这种方式被称为**延迟写**，当内核需要重用缓冲区来存放其他磁盘块数据时，会把所有延迟写的数据块写入磁盘，为了保证磁盘上实际文件系统与缓冲区内容一致，UNIX提供了三个函数，其函数原型如下所示：

```c
// 若成功，返回1；否则返回0
int fsync(int fd);
int fdatasync(int fd);

void synv(fd);
```

函数`sync`用于将修改过的块缓冲区写入队列，不等待实际写磁盘操作结束，系统中的`update`守护进程会定期的进行调用，以保证冲洗内核的块缓冲区。

函数`fsync`和`fdatasync`只对文件描述符指向的文件起作用，并且等待写磁盘操作结束后才返回。两者不同的是，`fdatasync`只针对于文件的数据部分，文件属性的修改内容不会刷新。

# 函数fcntl

函数`fcntl`可以改变已经打开的文件的属性，其函数原型如下所示：

```c
// 若成功，根据cmd不同返回不同的值；否则返回-1
int fcntl(int fd, int cmd, ...);
```

# 函数ioctl

函数`ioctl`是终端I/O操作中最常用的一个函数，这里仅给出该函数，其函数原型如下所示：

```c
// 若成功，根据request不同返回不同的值；否则返回-1
int ioctl(int fd, int request, ...);
```

# /dev/fd

较新的系统提供了名为`/dev/fd`的目录，其目录项为0、1、2等的文件，打开文件等效于复制文件描述符n。