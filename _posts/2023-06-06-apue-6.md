---
title: APUE —— VOL.6 进程控制
tags: "APUE"
key: apue-6
sidebar:
  nav: apue
---

本系列是APUE学习的记录笔记，参考了书籍《UNIX环境高级编程》和[视频课程](https://www.bilibili.com/video/BV18p4y167Md/)，本笔记的全部代码可以在[github项目](https://github.com/TypeFloat/Learning-APUE)中进行查看。文章主要介绍进程管理的相关内容。<!--more-->

# 进程标识

每个进程都有一个非负整形表示的唯一进程ID。虽然是唯一的，但是进程ID是可复用的，不同于文件描述符，进程ID采取延迟复用算法，以防止新进程被误认为是某个已终止的先前进程。除了进程ID，每个进程还有一些其他标识符，可以通过以下函数获得：

```c
// 调用进程的进程ID
pid_t getpid(void);
// 调用进程的父进程ID
pid_t getppid(void);
// 调用进程的有效用户ID
uid_t geteuid(void);
// 调用进程的实际用户ID
uid_t getuid(void);
// 调用进程的有效组ID
gid_t getegid(void);
// 调用进程的实际组ID
gid_t getgid(void);
```

系统中有一些专用进程：

- 0号进程通常是调度进程，也称为交换进程，该进程是内核的一部分，它不执行任何磁盘上的程序，因此也称为系统进程；
- 1号进程通常是init进程，在自举过程结束时由内核调用；
- 2号进程是负责虚拟存储器系统分页的守护进程。

守护进程是一种生存期较长的进程，通常在系统引导时启动，一直运行到系统关闭。守护进程通常不与控制终端关联，因此也不会因控制终端的关闭而受到影响。守护进程通常在后台运行，因此也不会受到前台进程的影响。守护进程通常是由`init`进程启动的，因此它们的父进程ID为1。

# 进程组与会话

每个进程除了一个进程ID之外，还属于一个进程组。进程组是一个或多个进程的集合，同一进程组的各进程接收来自同一终端的各种信号，每个进程组有唯一的进程组ID。每个进程组还有一个组长进程，其进程ID等于进程组ID。进程组的组长进程是第一个进入该组的进程，通常是由shell创建的。只要在某个进程组中有一个进程存在，则该进程就存在，与组长进程是否终止无关。

```c
// 调用进程的进程组ID
pid_t getpgrp(void);
// 调用进程的进程组ID，pid=0表示查看当前进程的进程组ID，pid>0表示查看pid指定进程的进程组ID
pid_t getpgid(pid_t pid);
// 将pid指定的进程加入到pgid指定的进程组中
int setpgid(pid_t pid, pid_t pgid);
```

会话是一个或多个进程组的集合，通常是由shell的管道将几个进程编成一组，函数`getsid`可以获取调用进程的会话首进程的进程组ID，进程调用`setsid`函数可以创建一个新会话，该函数的原型如下：

```c
pid_t getsid(pid_t pid);
pid_t setsid(void);
```

如果调用该函数的进程不是一个进程组组长，则此函数会创建一个新的会话：
- 调用进程变成新会话的会话首进程；
- 该进程成为一个新进程组的组长进程；
- 该进程没有控制终端，如果在调用`setsid`之前该进程有一个控制终端，则与该控制终端分离。

如果调用该函数的进程是一个进程组组长，则函数返回出错。

# 函数fork

 一个现有进程可以调用`fork`函数创建一个新进程，其函数原型如下：

```c
pid_t fork(void);
```

由`fork`创建的新进程被称为子进程，该函数调用一次，返回两次，子进程的返回值为0，父进程的返回值为子进程的PID。子进程和父进程共享正文段，但子进程的数据空间和堆栈是父进程的副本。

子进程虽然获得了父进程的数据段、堆栈的副本，但系统通常采用写时复制的方式，具体实现是：数据段和堆栈由父子进程共享，内核将它们的访问权限变为只读，如果父子进程中的任一个试图修改这些区域，则内核只为将被修改区域的内存制作一个副本。

# 函数vfork

`vfork`函数的调用序列和返回值与`fork`相同，但两者的语义不通。`vfork`函数用于创建一个新进程，而该新进程的目的是`exec`一个新程序或`exit`。`vfork`和`fork`的另一个区别是`vfork`保证子进程先运行，在子进程调用`exec`或`exit`后再调度运行。`vfork`的设计是为了提高子进程仅执行`exec`时的运行效率（不复制数据段和堆栈），所以随着写时复制技术的引入，其已经逐渐被弃用。

# 函数exit

在上一章中介绍过，一个进程有5种正常终止方式和3种异常终止状态。对子进程来说，无论其如何终止，都应该通知父进程它是如何终止的。正常终止时，进程可以调用`exit`函数设置终止状态；异常终止时，由内核设置终止状态。内核为每个终止的子进程保存了一定的信息（包括终止状态），父进程可以通过`wait`和`waitpid`来获取子进程的这些信息。

当子进程转为终止状态后，将会变为僵尸进程，等待父进程获取进程信息并释放占用的资源，如果父进程不进行处理，僵尸进程将一直存在。如果子进程还未执行结束或转为僵尸进程时，父进程已经消失，那这些子进程将会变为孤儿进程，进而被init进程收养。init进程将会负责处理其所有的僵尸子进程，所以僵尸进程不会永远占据系统资源。

# 函数wait和waitpid

当一个进程正常或异常终止时，内核将向其父进程发送`SIGCHLD`信号，因为子进程终止是一个异步事件，所以该信号也是一个异步信号。父进程可以选择忽略该信号，或者提供一个该信号发生时就被调用执行的函数。8.5节中提到了父进程获取子进程运行状态的函数`wait`和`waitpid`，其函数原型如下：

```c
pid_t wait(int *status);
pid_t waitpid(pid_t pid, int *status, int options);
```

当这两个函数被调用时：

- 如果子进程仍在运行，父进程将被阻塞；
- 如果一个子进程已终止，则返回该进程的终止状态；
- 如果该进程没有子进程，立即出错返回;
- `waitpid`可以等待某一个子进程，并可以通过参数`options`设置非阻塞的等待。

# 竞争条件

当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，称发生了竞争条件。为了避免竞争条件，在多个进程之间需要有某种形式的信号发送和接受的方法。

# 函数exec

当进程调用一种`exec`函数后，该进程执行的程序将被完全替换为新程序，从新程序的`main`函数开始执行。因为调用`exec`函数并不产生新进程，所有进程ID不发生改变，只使用磁盘上的一个新程序替换当前程序的正文段、数据段和堆栈。`exec`函数族有多个函数，其函数原型如下：

```c
int execl(const char *path, const char *arg0, ..., /*, (char *)0, */);
int execle(const char *path, const char *arg0, ..., /* (char *)0 char *const envp[] */);
int execlp(const char *file, const char *arg0, ..., /*, (char *)0, */);
int execv(const char *path, char *const argv[]);
int execve(const char *path, char *const argv[], char *const envp[]);
int execvp(const char *file, char *const argv[]);
```

# 函数system

函数`system`的作用是在程序中执行一个命令字符串，其函数原型为：

```c
int system(const char *command);
```

其本质是调用了`fork`、`exec`、`waitpid`，因此共有3种返回值：

- `fork`失败或`waitpid`返回出`EINTR`外的出错，返回-1并设置`errno`；
- 如果`exec`失败，返回值为127
- 如果函数执行成功，则会返回子进程的终止状态。

# 进程会计

大多数UNIX系统提供了一个选项以进行进程会计处理，其目的是跟踪系统中的进程，以便于计算机资源的使用情况。进程会计的实现方式是在内核中设置一个标志，当进程终止时，内核将会把进程的一些信息写入到一个文件中，这些信息包括：CPU时间总量、用户ID、组ID、启动时间等。但进程会计的使用方法各个UNIX系统不同，因此需要查看系统文档。

# 进程时间 

一个进程的执行一般有3个度量时间：墙上时钟时间、用户CPU时间和系统CPU时间，任何一个进程可以调用`times`函数来获取自己以及已终止子进程的上述时间，其函数原型如下：

```c
clock_t times(struct tms *tp);
```