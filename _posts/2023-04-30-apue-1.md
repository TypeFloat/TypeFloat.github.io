---
title: APUE学习 —— VOL.1 UNIX基础
tags: "APUE"
key: apue-1
sidebar:
  nav: apue
---

本系列是APUE学习的记录笔记，参考了书籍《UNIX环境高级编程》和[视频课程](https://www.bilibili.com/video/BV18p4y167Md/)，本笔记的全部代码可以在[github项目](https://github.com/TypeFloat/Learning-APUE)中进行查看。本节是第一章，主要介绍了UNIX系统的基础知识。<!--more-->

# UNIX体系结构

从严格意义上讲，可将操作系统定义为一种软件，它控制计算机硬件资源，提供程序运行环境，通常将这种软件称为内核，如图1-1所示。

![](/assets/posts/apue-1-1.png)
图1-1 UNIX操作系统的体系结构

内核的接口被称为**系统调用**，公用函数库构建在系统调用接口之上，应用程序既可使用公用函数库也可使用系统调用。shell是一个特殊的应用程序，为运行其他应用程序提供了接口。

从广义上说，操作系统包括了内核和一些其他软件，例如系统实用程序、应用程序、shell以及公用函数库。

# 登陆

## 登录名

与用户相关的信息存储在**系统口令文件**中，通常是`/etc/passwd`，口令文件中的登录项由7个以冒号分隔的字段组成，依次是：登录名、加密口名、数字用户ID、数字组ID、注释字段、其实目录以及shell程序。但现在的系统中，加密口令大多被存储至另外一个文件中。

## shell

在用户登录后，系统会自动为用户启动一个shell，shell是一个命令行解释器，读取用户输入，然后执行命令。用户输入通常来自终端（交互式shell）或者文件（shell脚本）。系统从口令文件中相应用户登录项的最后一个字段获取应该为用户执行哪一个shell。

# 文件和目录

## 文件系统

UNIX文件系统是目录和文件的一种层次结构。所有东西的起点称为**根目录**，该目录的名称为`/`。

**目录是一个包含目录项的文件**。在逻辑上，可以认为每个目录项都包含一个文件名，同时还包含说明该文件属性的信息。文件属性包含文件类型（普通文件或者目录）、文件大小、文件所有者、文件权限以及文件最后修改时间等。

## 文件名

目录中的各个名字称为**文件名**。只有斜线和空字符这两个字符不能出现在文件名中。

创建目录时会自动创建两个文件名，`.`和`..`，`.`指向当前目录，`..`指向父目录。在最高层次的根目录中，`.`和`..`相同。

## 路径名

由斜线分隔的一个或多个文件名组成的序列构成**路径名**，以斜线开头的路径名称称为**绝对路径名**，否则称为**相对路径名**。文件系统根`/`是一个特殊的绝对路径名，它不包含文件名。

shell中`ls`指令可以打印指定**路径名**下的所有**文件名**，[示例1-1](https://github.com/TypeFloat/Learning-APUE/blob/main/src/1-1.c)给出了以上功能的简单实现。

## 工作目录

每个进程都有一个**工作目录**，也称**当前工作路径**。所有的相对路径名都从工作目录开始解释，进程可以使用`chdir`函数更改其工作目录。

## 起始目录

登录时，工作目录设置为**起始目录**，该目录从1.3节中提到的口令文件中获取。

# 输入和输出

## 文件描述符

文件描述符通常是一个小的非负整数，内核用以标识一个特定进程正在访问的文件。当内核打开一个现有文件或创建一个新文件时，它都返回一个文件描述符。

## 标准输入、标准输出和标准错误

一般情况下，当运行一个新程序时，shell会为该进程打开3个文件描述符，即标准输入`stdin`、标准输出`stdout`、标准错误`stderr`。如果不做特殊处理，这三个描述符都指向**终端**，大多数shell都提供了相应的方法使描述符重定向到某个文件。

[示例1-2](https://github.com/TypeFloat/Learning-APUE/blob/main/src/1-2.c)给出了通过读写终端的简单实现，若将标准输入和标准输出进行重定向，则可以使用相同的代码实现文件复制，例如`./cp < infile > outfile`。

## 不带缓冲的I/O

函数`open`、`read`、`write`、`lseek`、`close`等提供了不带缓冲的I/O，这些函数都对文件描述符进行操作。标准I/O函数为不带缓冲I/O函数提供了带缓冲的接口，使用标准I/O函数无需担心如何选取最佳的缓冲区大小。

## 标准I/O

标准I/O函数为不带缓冲的I/O函数提供了一个带缓冲的接口，使用标准I/O函数无需担心如何选取最佳的缓冲区大小。使用标准I/O函数还可以简化对输入行的处理。

[示例1-3](https://github.com/TypeFloat/Learning-APUE/blob/main/src/1-3.c)给出了与[示例1-2](https://github.com/TypeFloat/Learning-APUE/blob/main/src/1-2.c)相同的功能，不过是用标准I/O实现的。

# 程序和进程

## 程序

程序是一个存储在磁盘上某个目录中的**可执行文件**。**内核**使用`exec`函数将程序写入**内存**，并执行程序。

## 进程和进程ID

程序的执行实例称为**进程**，某些操作系统用任务表示正在被执行的程序。UNIX系统确保每个进程都有一个唯一的数字标识符，称为进程ID，进程ID是一个非负整数。

[示例1-4](https://github.com/TypeFloat/Learning-APUE/blob/main/src/1-4.c)可以获取并打印进程ID。

## 进程控制

用于进程控制的函数主要有`fork`、`exec`、`waitpid`。

[示例1-5](https://github.com/TypeFloat/Learning-APUE/blob/main/src/1-5.c)给出了使用进程控制函数实现类似shell功能的简单实现。

## 线程和线程ID

多个控制线程可以充分利用多处理器的并行能力。一个进程内的所有线程共享同一地址空间、文件描述符、栈以及进程相关的属性。因为同一进程的线程能够访问同一存储区，因此各线程在访问共享数据时需要采取同步措施以避免不一致性。与进程相同，线程使用线程ID进行标识，但是线程ID只在它所属的进程内起作用。

# 出错处理

## 错误指示

在UNIX系统函数出错时，通常会返回一个负值，而整形变量`errno`通常被设置为具有特定信息的值。POSIX和ISO C将`errno`定义为一个符号，它扩展成一个可修改的整形左值，它可以是一个包含出错编号的整数，也可以是一个返回出错编号指针的函数（多线程编程环境）。

对于致命性错误，通常能做的就是在用户屏幕上打印出错信息或写入日志信息然后退出程序。对于非致命性的出错，有时可以较妥善地进行处理。最终，由应用的开发者决定在哪些情况下应用程序可以从出错中恢复。如果能够采用一种合理的恢复策略，那么可以避免应用程序异常终止，进而改善应用程序的健壮性。

`errno`可以帮助开发者确定程序出现的错误，[示例1-6](https://github.com/TypeFloat/Learning-APUE/blob/main/src/1-6.c)展示了两种`errno`的使用方法，相关函数的函数原型如下所示：

```c
void perror(const char *s);
char * strerror(int errnum);
```

## 出错恢复

可以将程序中遇到的错误分为两类：致命性和非致命性。对于致命性错误，无法执行恢复动作。对于非致命性错误，有时可以妥善处理。

对于资源相关的非致命性出错的典型恢复操作时延迟一段时间，然后重试。最终使用怎样的处理方法由程序的开发者决定，如果能够采用一种合理的恢复策略，可以避免应用程序异常终止，可以改善应用程序的健壮性。

# 用户标识

## 用户ID

口令文件登录项的**用户ID**是一个数值，向系统标识各个不同的用户，通常每个用户有一个唯一的用户ID。

用户ID为0的用户为**根用户**或**超级用户**，对应登录名为`root`。如果一个进程具有超级用户特权，则大多数文件权限检查都不再进行。

## 组ID

口令文件登录项包括用户的**组ID**，由系统管理员在指定用户登录名时分配的。组被用于将若干用户集合到项目或部门中去，这种机制允许同组的各个成员之间共享资源。

组文件`/etc/group`将组名映射为组ID。

使用数值的用户ID和组ID是历史上形成的，这极大减少了存储占用，但为了方便实用，口令文件中包含了从用户名到用户ID的映射、组文件中包括了组名到组ID的映射。

[示例1-7](https://github.com/TypeFloat/Learning-APUE/blob/main/src/1-7.c)给出了获取用户ID和组ID的方法。

## 附属组ID

除了在口令文件中对一个登录名指定的一个组ID外，大多数UNIX系统还允许用户属于另外一些组，这些组通过查找组文件可以获得。POISX要求系统至少支持8个附属组，实际上大多数系统都至少支持16个附属组。

# 信号

信号用于通知进程发生了某种情况。进程有以下3种处理信号的方式：

1. 忽略信号；
2. 按系统默认方式处理；
3. 提供一个函数，信号发生时调用该函数，称为捕捉信号。

终端键盘上有两种产生信号的方法，分别是中断键（通常是`Ctrl+C`）和退出键（通常是`Ctrl+\`），他们可以用于中断当前运行的进程。另一种产生信号的方法是调用`kill`函数。进程A调用此函数后可以向进程B发送信号，但进程A和B必须同属于一个用户或者A的所属者是超级用户。

[示例1-8](https://github.com/TypeFloat/Learning-APUE/blob/main/src/1-7.c)给出了捕捉信号和处理信号的方法。

# 时间值

当度量一个进程的执行时间时，UNIX系统为一个进程维护了3个进程时间值，分别为时钟时间、用户CPU时间、系统CPU时间。

时钟时间又称墙上时钟时间（wall clock time），它指的是进程运行时间的总量，该值与系统中同时运行的进程数有关。

用户CPU时间是执行**用户指令**所用的时间量。系统CPU时间是为该进程执行**内核程序**所经历的时间。

# 系统调用和库函数

各种版本的UNIX实现都提供了内核的入口点，即系统调用。为了隐藏不同操作系统给出的系统调用不同的细节，编程语言提供了供程序员使用的库函数，库函数通常调用一个或多个内核的系统调用，并不是所有的库函数调用系统调用。应用程序既可以调用系统调用也可以调用库函数。

从实现者的角度来看，系统调用和库函数之间有根本区别，但从用户角度其区别并不重要。

除了图1-2所示的差别外，系统调用和库函数之间的另一个差别是：系统调用通常提供一种最小接口，而库函数通常提供比较复杂的功能。

![](/assets/posts/apue-1-2.png)
图1-2 C语言库函数和系统调用之间的差别