---
title: C++学习 —— VOL.5 面向对象编程——类
tags: C++
key: C++-5
sidebar:
  nav: c++
---

本节主要介绍了C++中面向对象变种的重要概念——类的使用。<!--more-->

# 写在前面

这篇笔记是根据国外的大佬录制的教学视频进行整理的，[视频戳这儿](https://www.youtube.com/watch?v=18c3MTX0PK0&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb)，B站也有中文的搬运，[视频戳这儿](https://www.bilibili.com/video/BV1N24y1B7nQ?p=2&vd_source=0307132b97183cff4ff2138cf704f827)。这篇笔记中很多语言相通的概念介绍的非常简单，因此该笔记可能更适合已经学过某一门编程语言的C++初学者。

# 类

## 面向对象编程

面向对象编程（Object-Oriented Programming，简称OOP）是一种编程思想或方法，它将现实世界中的事物抽象成程序中的对象，通过定义对象间的交互关系来描述程序的行为和逻辑。它强调的是“对象”而不是“过程”或“函数”，每个对象都有自己的状态、行为和标识，并且可以与其他对象进行互动和通信。在面向对象编程中，代码被组织成一个个独立的类，类是对象的模板，包含了一些属性和方法，以及对其他类的引用。这种编程方法具有封装、继承和多态等特性，能够提高代码重用性、可维护性和灵活性。

## C++类的定义

在C++中，类的定义由两部分组成：类声明和类实现。类声明包含了类的名称、属性和方法的声明，属性和方法都是类的成员，类实现包含了类的方法的实现。声明类的关键字为`class`，也可以使用C中用于定义结构体的关键字`struct`，其二者的区别是可见性不同。习惯使用`struct`定义纯属性的类，类似于C语言中结构体的用法。

```cpp
// 类声明
class Entity
{
    int a;
    int b;
    int func(void);
}
// 类实现
Entity::func(void)
{
    return a + b;
}
```

## 可见性

C++中类的可见性分为三种：`public`、`private`和`protected`。`public`表示公有的，`private`表示私有的，`protected`表示受保护的。这三种可见性的区别在于，公有的成员可以被类的外部访问，私有的成员只能被类的内部访问，受保护的成员可以被类的内部和子类的内部访问。默认情况下，由`class`声明的类的成员的可见性为私有的，而由`struct`声明的类的成员的可见性为公有的。在类中，可以使用`public`、`private`和`protected`关键字来定义成员的可见性。

```cpp
Class Entity
{
private:
    int a;
protected:
    int b;
public:
    int c;
}
```

# 类中的特殊函数

## 构造函数

C++中的构造函数是一种特殊的成员函数，会在创建类对象时自动调用：
- 构造函数的名称必须与类名相同，没有返回类型（包括void）。
- 如果没有定义构造函数，则编译器自动提供一个默认构造函数，默认构造函数不做任何工作。
- 构造函数可以被重载，以便创建具有不同参数的对象。
- 构造函数可以使用成员初始化列表来初始化数据成员，语法为“冒号”后面跟着数据成员的初始化式。使用成员初始化列表通常比在构造函数体内赋值更高效，因为它避免了在构造函数体内对成员变量的默认初始化，然后再进行赋值操作。
- 构造函数可以被标记为explicit，防止隐式转换。如果将构造函数标记为explicit，则不能通过隐式转换调用它，必须显式地调用该构造函数。
- 构造函数可以抛出异常，但它们通常应该避免这样做，因为在构造函数中抛出异常可能会导致对象以未定义的状态被创建。
- 构造函数不能被声明为虚函数，因为在对象创建期间虚表还没有生成。

上述内容中，有几个点需要单独介绍一下。

1. 默认构造函数：C++会为类创建许多默认函数，例如默认构造函数、默认析构函数等，如果不想使用默认值，可以重载默认函数或者删除该函数，例如`Entity() = delete;`。需要注意，一旦提供了一个构造函数，编译器就不会再提供默认构造函数了，因此如果想要使用默认构造函数，需要显式地声明一个默认构造函数（`Entity() = default;`）。默认构造函数不接受任何参数，如果类中的成员变量没有被初始化，那么它们的值是未定义的。
2. 重载：C++中的函数重载是指在同一个作用域中，可以有多个同名的函数，但是它们的参数列表必须不同，包括参数的类型、个数和顺序。函数重载的作用是，可以使用相同的函数名来实现不同的功能，这样可以提高代码的可读性。需要注意的是，函数重载与返回值无关，因此不能通过返回值来区分重载函数。
3. 虚函数：虚函数会在类的继承中进行介绍。

## 析构函数

在C++中，析构函数（Destructor）是一种特殊的成员函数，它用于在对象生命周期结束时执行一些清理工作。当对象不再被使用或者被系统销毁时，析构函数会自动地调用，并在其中释放分配的资源、断开连接等。析构函数的名称必须与类名相同，前面加上一个波浪号（~），没有返回类型（包括void），也不接受任何参数。如果没有定义析构函数，则编译器会自动提供一个默认析构函数，它不做任何工作。析构函数不能被声明为虚函数，因为在对象销毁期间虚表已经被销毁了。

# 类的继承

在C++中，类的继承是一种特性，它允许一个类（称为派生类）从另一个类（称为基类）继承属性和方法，并且可以添加自己的属性和方法。类的继承主要有以下几个特点：

- 派生类可以继承基类的`public`和`protected`成员，但不能继承`private`成员。
- 派生类可以在其内部访问从基类继承来的`protected`成员。
- 派生类不能继承基类的构造函数、析构函数和赋值运算符重载函数。但是可以通过调用基类构造函数来初始化从基类继承来的成员变量。
- 派生类可以覆盖（或者说重载）基类的虚函数，使其按照派生类的需求进行实现。
- 派生类可以定义自己的成员变量和成员函数，也可以重载（overload）基类的函数。

```cpp
// 基类
class Shape {
public:
    void setColor(string color) {
        m_color = color;
    }

    virtual void draw() {
        cout << "Draw a shape." << endl;
    }

protected:
    string m_color;
};

// 派生类
class Circle : public Shape {
public:
    Circle(double radius) : m_radius(radius) {}

    void setRadius(double radius) {
        m_radius = radius;
    }

    virtual void draw() override {
        cout << "Draw a circle." << endl;
    }

private:
    double m_radius;
};
```

## 虚函数

`virual`关键字指明了一个函数是一个虚函数，C++通过建立虚表来管理虚函数，这使得在运行时可以动态地确定调用哪个函数。如果仅使用重载的方式覆盖父类的一个方法，那程序在运行时可能会错误调用父类的函数而不是子类重载的函数。虚函数可以被派生类重载，使其按照派生类的需求进行实现。如果派生类没有覆盖基类的虚函数，那么在派生类中调用该虚函数时，会调用基类的虚函数。如果派生类覆盖了基类的虚函数，那么在派生类中调用该虚函数时，会调用派生类的虚函数。

如果基类中没有实现某个虚函数，则该函数称为纯虚函数，用`virtual func()=0`进行定义。如果子类没有实现该虚函数，编译器将报错。